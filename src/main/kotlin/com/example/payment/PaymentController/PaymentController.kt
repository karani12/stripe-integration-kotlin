package com.example.payment.PaymentController

//create stripe webhook endpoint

import com.stripe.Stripe
import com.stripe.exception.SignatureVerificationException
import com.stripe.model.Event
import com.stripe.model.PaymentIntent
import com.stripe.net.Webhook
import com.stripe.param.PaymentIntentCreateParams
import org.springframework.stereotype.Controller
import org.springframework.ui.Model
import org.springframework.web.bind.annotation.*
import java.util.logging.Logger
/*
* Payment data class to hold the payment information. This is based on the data need to create a payment intent.
* This  is the minimum data needed to create a payment intent.
* For more on this read the stripe documentation on payment intents(https://stripe.com/docs/payments/payment-intents)
* */
data class paymentPayload (
   var currency      : String?           = null,
   var amount        : Int?              = null,
   var paymentMethod : ArrayList<String> = arrayListOf()
)
@RestController
class PaymentController {

// webhook secret obtained from stripe dashboard
  val  endpointSecret : String = "whsec_6805d101d6e65fb81b3af8509b982c315c3dc0ae51052c81ab215698fcf71f4c"
/*
* Webhook is used to listen to events from stripe. This is used to listen to payment intent events.
* The events are used to update the payment intent status.
* When an event subscribed to is triggered, stripe sends a post request to the webhook endpoint.
* This allows you to set up functions that are triggered when a payment intent is created, updated or canceled.
* For more on this read the stripe documentation on webhooks(https://stripe.com/docs/webhooks)
* */
    @PostMapping("/webhook")
    fun handleWebhook(@RequestBody payload:String,  @RequestHeader("Stripe-Signature") sigHeader: String): String {

        var event: Event? = null
        try {
            event = Webhook.constructEvent(payload, sigHeader, endpointSecret)
        } catch (e: SignatureVerificationException) {
            // Invalid signature
            Logger.getLogger(PaymentController::class.java.name).warning("Invalid signature.")
            return ""
        }
        // Handle the event
        when (event.type) {


            "payment_intent.succeeded" -> {
                val paymentIntent = event.data as PaymentIntent
//            set up your logic to handle the payment intent once it is successful
                Logger.getLogger(PaymentController::class.java.name).info("PaymentIntent was successful.")
            }
            "payment_method.attached" -> {
                val paymentMethod = event.data as PaymentIntent
//            set up your logic to handle the payment method once it is attached
                Logger.getLogger(PaymentController::class.java.name).info("PaymentMethod was attached to a Customer.")
            }
            /*
            * Stripe  has more intent methods that can be subscribed to. These are just a few of them.
            * For more on this read the stripe documentation on webhooks(https://stripe.com/docs/webhooks)
            * */

            else -> {

                Logger.getLogger(PaymentController::class.java.name).info("Unhandled event type: " + event.type)
            }
        }
        return ""
    }
    /*
    * This is the endpoint that is used to create a payment intent.
    * It takes a payload of type paymentPayload as a parameter.
    * The payload contains the payment information.
    * For more on this read the stripe documentation on payment intents(https://stripe.com/docs/payments/payment-intents)
    * */
    @PostMapping("/create-payment-intent")
    fun createPaymentIntent(@RequestBody payload: paymentPayload): Map<String, Any> {

//  set up your stripe secret key obtained from your stripe dashboard (https://dashboard.stripe.com/test/apikeys)
        println(payload.amount?.toLong())

        Stripe.apiKey = "sk_test_51LrFM1K7lMXQ0gyz4xEK2R9uVHYnioQxlcpQFrXd2ppagVpaB3hoVqbAngDz4ErFOlM1Fo86s0O76i0833GZao8G00jAEU1OZD"
        val paymentIntentParams = PaymentIntentCreateParams.builder()
                .setAmount(payload.amount?.toLong())
                .setCurrency(payload.currency)
                .addPaymentMethodType("card")
                .build()
        val paymentIntent = PaymentIntent.create(paymentIntentParams)
        return mapOf("clientSecret" to paymentIntent.clientSecret)
    }
}
//Controller used to serve the payment page
@Controller
class PaymentController2 {
        @GetMapping("/payment")
        fun payment(): String {
            return "payment"
        }

}

//alternatively using a payment link generated by the chatbot we could get the amount and currency from the link
//and use it to create a payment intent

//create a controller with a get mapping and route params as currency, amount and payment method
//use the route params to create a payment intent

@Controller
class PaymentController3 {
//    eg /payment/usd/1000/card

    @GetMapping("/payment/{currency}/{amount}/{paymentMethod}")
    fun payment(@PathVariable currency: String, @PathVariable amount: Int, @PathVariable paymentMethod: String, model: Model): String {
        return "paymentWithRouteParams"
    }
}



